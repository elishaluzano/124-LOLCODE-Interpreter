<head>
	<link href="materialize/css/materialize.css" rel="stylesheet"/>
	<title>Ang Ganda ni Ma'am Kat LOLterpreter</title>
	<style>
		#codeDiv{
			height: 50vh;
			padding: 10px;
		}
		#codeText{
			width: 20vw;
		}
		#lexemeDiv{
			overflow-y: scroll;
			overflow-x: fixed;
			height: 50vh;
		}
		#codeText{
			height: 30vh;
		}
	</style>
<head>
<body>
	<div class="container">
		<div class="row">
			<div id="codeDiv" class="col s4">
				<div>
					<h5>CODE</h5>
					<input id="codeFile" type="file" onclick="clearTable()" />
					<textarea id="codeText" onfocus="clearTable()"></textarea>
				</div>
			</div>
			<div id="lexemeDiv" class="col s4">
				<div>
					<h5>LEXEME TABLE</h5>
					<table>
						<thead>
							<tr>
								<th>Lexeme</th>
								<th>Description</th>
							</tr>
						</thead>
						<tbody id="lexemeTable">
						</tbody>
					</table>
				</div>
			</div>
			<div class="col s4">
				<div>
					<h5>SYMBOL TABLE</h5>
					<table>
						<thead>
							<tr>
								<th>Symbol</th>
								<th>Description</th>
							</tr>
						</thead>
						<tbody>
						</tbody>
					</table>
				</div>
			</div>
		</div>
	</div>
	<div class="container center">
		<button class="btn" id="executeButton">EXECUTE</button>
	</div>
	<div class="container">
		<div class="row">
			<div id="consoleDiv" class="col s12 red">
				<h5>CONSOLE</h5>
			</div>
		</div>
	</div>

	<script>
		var executeButton = document.getElementById("executeButton");

		function clearTable() {
			var lexemeTable = document.getElementById("lexemeTable");
			var newtbody = document.createElement("tbody");
			newtbody.id = "lexemeTable";
			lexemeTable.parentNode.replaceChild(newtbody, lexemeTable);
		}

		function loadCode(e) {
			var file = e.target.files[0];
			if (!file) {
				alert("Can not read file");
			}
			var reader = new FileReader();
 			reader.onload = function(e) {
				var contents = e.target.result;
				document.getElementById("codeText").value = contents;
			};
  			reader.readAsText(file);
		}

		document.getElementById('codeFile').addEventListener('change', loadCode, false);

		executeButton.onclick = function() {
			var lexemeTable = document.getElementById("lexemeTable");
			var code = document.getElementById("codeText").value;
			clearTable();
			var lexemeTable = document.getElementById("lexemeTable");

			function addToLexemeTable(lexeme, description) {
					var tr = document.createElement("tr");

					var tdLexeme = document.createElement("td");
					var tnLexeme = document.createTextNode(lexeme);
					tdLexeme.appendChild(tnLexeme);

					var tdDesc = document.createElement("td");
					var tnDesc = document.createTextNode(description);
					tdDesc.appendChild(tnDesc);

					tr.appendChild(tdLexeme);
					tr.appendChild(tdDesc);

					lexemeTable.appendChild(tr);
				}

			var tokens = code.split("\n");

			// LEXEMES AND DESCRIPTION

			const HAIlex = "HAI";
			const HAIdesc = "Delimeter to mark the start of the program";
			const KTHXBYElex = "KTHXBYE";
			const KTHXBYEdesc = "Delimeter to mark the end of the program";
			const BTWlex = "BTW";
			const BTWdesc = "Indicates the start of a single-line comment";
			const OBTWlex = "BTW";
			const OBTWdesc = "Indicates the start of a multi-line comment";
			const TLDRlex = "TLDR";
			const TLDRdesc = "Indicates the end of a multi-line comment"
			const IHASAlex = "I HAS A";
			const IHASAdesc = "Declares a variable without an initial value";
			const ITZlex = "ITZ";
			const ITZdesc = "Assigns a value to a variable immediately after its declaration";
			const Rlex = "R";
			const Rdesc = "Assigns a value to a variable";
			const MAEKlex = "MAEK";
			const MAEKdesc = "Operator that explicitly casts an expressionâ€™s value";
			const ISNOWAlex = "IS NOW A";
			const ISNOWAdesc = "Explicitly re-cast a variable";
			const VISIBLElex = "VISIBLE";
			const VISIBLEdesc = "Prints a string to the output stream";
			const GIMMEHlex = "GIMMEH";
			const GIMMEHdesc = "Reads a string from the input stream into the variable";
			const SMOOSHlex = "SMOOSH";
			const SMOOSHdesc = "Concatenates the given YARNs";
			const MKAYlex = "MKAY";
			const MKAYdesc = "Delimiter to mark the end of a list of arguments";
			const ANlex = "AN";
			const ANdesc = "Indicates that there are more arguments for a certain operation";
			const BOTHSAEMlex = "BOTH SAEM";
			const BOTHSAEMdesc = "Comparison operator for equality";
			const DIFFRINTlex = "DIFFRINT";
			const DIFFRINTdesc = "Comparison operator for inequality"
			const BIGGROFlex = "BIGGR OF";
			const BIGGROFdesc = "Comparison operator that returns the argument with the larger/ largest value from the list arguments";
			const SMALLROFlex = "SMALLR OF";
			const SMALLROFdesc = "Comparison operator that returns the argument with the smaller/ smallest value from the list arguments";

			const WTFlex = "WTF?";
			const OIClex = "OIC";

			const WINlex = "WIN";
			const WINdesc = "Boolean value for true";
			const FAILlex = "FAIL";
			const FAILdesc = "Boolean value for false";

			// LITERALS AND DELIMITERS

			const YARNdesc = "String Literal";
			const YARNdelimiter = "\"";
			const YARNdelimiterdesc = "String Delimiter"
			const NUMBRdesc = "Integer Literal"
			const NUMBARdesc = "Floating-point Literal";

			const COMMENTLiteraldesc = "Single-line comment";
			const VARIABLEdesc = "Variable Expression";

			// REGEX

			const BTWpatt = /^BTW .*$/;
			const OBTWpatt = /^OBTW .*TLDR$/m;
			const IHASApatt = /^I HAS A (\w\S*)$/;
			const VARIABLEpatt = /^\D$/;
			const IHASAITZpatt = /(I HAS A) (\w\S*) (ITZ) ("?.*"?|\S+)$/;
			const VISIBLEpatt = /^VISIBLE ("?.*"?|\w+)$/;
			const GIMMEHpatt = /^GIMMEH \w*$/;
			const ITZpatt = /^ITZ \w$/;
			const Rpatt = /^\w* R ("?.*"?|\w*)$/;
			const SMOOSHMKAYpatt = /^SMOOSH ("?.*"?|\w+) (AN ("?.*"?|\w+))+$/;
			const COMPARISONpatt = /^(BOTH SAEM|DIFFRINT|BIGGR OF|SMALLR OF) ("?.*"?|\w+) (AN) ("?.*"?|\w+)$/;
			const WTFpatt = /^WTF\?$/;
			const OMGpatt = /^OMG ("?.*"?|\w+)$/;	
			const YARNpatt = /".*"/;
			const NUMBRpatt = /^-?\d+$/;
			const NUMBARpatt = /^-?\d+.\d+$/;
			const WINpatt = /^WIN$/;
			const FAILpatt = /^FAIL$/;
			const BOTHSAEMpatt = /BOTH SAEM/;
			const DIFFRINTpatt = /DIFFRINT/;
			const BIGGROFpatt = /BIGGR OF/;
			const SMALLROFpatt = /SMALLR OF/;
			const ANpatt = /AN/;


			for(var i = 0; i<tokens.length; i++){
				if(i === 0 && tokens[0] === "HAI"){
					addToLexemeTable(HAIlex, HAIdesc);
				}
				if (i === tokens.length - 1 && tokens[i] === "KTHXBYE") {
					addToLexemeTable(KTHXBYElex, KTHXBYEdesc);
				}
				if (i !== 0 && i !== tokens.length){
					if (tokens[i].match(VISIBLEpatt)) {
						addToLexemeTable(VISIBLElex, VISIBLEdesc);

						var args = tokens[i].slice(VISIBLElex.length);

						if(args.match(YARNpatt)){
							args = args.substring(1, (args.length-1));

							addToLexemeTable(YARNdelimiter, YARNDelimiterdesc);
							addToLexemeTable(args, YARNdesc);
							addToLexemeTable(YARNDelimiter, YARNDelimiterdesc);
						}
						else addToLexemeTable(args, VARIABLEdesc);

					}
					else if (tokens[i].match(GIMMEHpatt)) {
						addToLexemeTable(GIMMEHlex, GIMMEHdesc);

						var args = tokens[i].slice(GIMMEHlex.length);

						if(args.match(YARNpatt)){
							args = args.substring(1, (args.length-1));

							addToLexemeTable(YARNDelimiterlex, YARNDelimiterdesc);
							addToLexemeTable(args, YARNdesc);
							addToLexemeTable(YARNDelimiterlex, YARNDelimiterdesc);
						}
						else addToLexemeTable(args, VARIABLEdesc);
					}
					else if (tokens[i].match(BTWpatt)) {
						addToLexemeTable(BTWlex);

						var args = tokens[i].slice(GIMMEHlex.length);
						addToLexemeTable(args, COMMENTLiteraldesc);
					}
					else if (tokens[i].match(COMPARISONpatt)) {
						var args = tokens[i].match(COMPARISONpatt);
						
						if (args[1].match(BOTHSAEMlex)) addToLexemeTable(BOTHSAEMlex, BOTHSAEMdesc);
						else if (args[1].match(DIFFRINTlex)) addToLexemeTable(DIFFRINTlex, DIFFRINTdesc);
						else if (args[1].match(BIGGROFlex)) addToLexemeTable(BIGGROFlex, BIGGROFdesc);
						else if (args[1].match(SMALLROFlex)) addToLexemeTable(SMALLROFlex, SMALLROFdesc);

						for (var j = 2; j < args.length; j++) {
							if(args[j].match(YARNpatt)){
								var yarn = args[j].substring(1, (args.length-1));

								addToLexemeTable(YARNDelimiterlex, YARNDelimiterdesc);
								addToLexemeTable(yarn, YARNdesc);
								addToLexemeTable(YARNDelimiterlex, YARNDelimiterdesc);
							}
							else if(args[j].match(NUMBRpatt)) addToLexemeTable(args[j], NUMBRdesc);
							else if(args[j].match(NUMBARpatt)) addToLexemeTable(args[j], NUMBRdesc);
							else if(args[j].match(WINpatt))	addToLexemeTable(WINlex, WINdesc)
							else if(args[j].match(FAILpatt)) addToLexemeTable(FAILlex, FAILdesc)
							else if(args[j].match(ANpatt)) addToLexemeTable(ANlex, ANdesc);
							else addToLexemeTable(args[j], VARIABLEdesc);
						}

					}
					else if (tokens[i].match(IHASApatt)) {
						addToLexemeTable(IHASAlex, IHASAdesc);
						args = tokens[i].slice(IHASAlex.length);
						addToLexemeTable(args, VARIABLEdesc);
					}
					else if (tokens[i].match(IHASAITZpatt)) {
						var args = tokens[i].match(IHASAITZpatt);
						addToLexemeTable(IHASAlex, IHASAdesc);
						addToLexemeTable(args[2], VARIABLEdesc);
						addToLexemeTable(args[3], ITZdesc);
						if (args[4].match(NUMBRpatt)) addToLexemeTable(args[4], NUMBRdesc);
						else if (args[4].match(NUMBARpatt)) addToLexemeTable(args[4], NUMBARdesc);
						else if (args[4].match(WINpatt)) addToLexemeTable(args[4], WINdesc);
						else if (args[4].match(FAILpatt)) addToLexemeTable(args[4], FAILdesc);
					}
				}
			}
		}
	</script>
</body>